(* Copyright (c) Open Enclave SDK contributors.
   Licensed under the MIT License. *)

open Intel.Ast
open Printf

(** ----- Begin code borrowed and tweaked from {!CodeGen.ml}. ----- *)
let is_foreign_array (pt : parameter_type) =
  match pt with
  | PTVal _ -> false
  | PTPtr (t, a) -> ( match t with Foreign _ -> a.pa_isary | _ -> false )

(** Get the array declaration from a list of array dimensions. Empty
    [ns] indicates the corresponding declarator is a simple identifier.
    Element of value -1 means that user does not specify the dimension
    size. *)
let get_array_dims (ns : int list) =
  let get_dim n = if n = -1 then "[]" else sprintf "[%d]" n in
  String.concat "" (List.map get_dim ns)

let get_typed_declr_str (ty : atype) (declr : declarator) =
  let tystr = get_tystr ty in
  let dmstr = get_array_dims declr.array_dims in
  sprintf "%s %s%s" tystr declr.identifier dmstr

(** Check whether given parameter [pt] is [const] specified. *)
let is_const_ptr (pt : parameter_type) =
  let aty = get_param_atype pt in
  match pt with
  | PTVal _ -> false
  | PTPtr (_, pa) -> (
      if not pa.pa_rdonly then false
      else match aty with Foreign _ -> false | _ -> true )

(** Generate parameter [p] representation. *)
let get_parameter_str (p : pdecl) =
  let pt, (declr : declarator) = p in
  let aty = get_param_atype pt in
  let str = get_typed_declr_str aty declr in
  if is_const_ptr pt then "const " ^ str else str

(** [conv_array_to_ptr] is used to convert Array form into Pointer form.
    {[
      int array[10][20] => [count = 200] int* array
    ]}

    This function is called when generating proxy/bridge code and the
    marshalling structure. *)
let conv_array_to_ptr (pd : pdecl) : pdecl =
  let pt, declr = pd in
  let get_count_attr ilist =
    (* XXX: assume the size of each dimension will be > 0. *)
    ANumber (List.fold_left (fun acc i -> acc * i) 1 ilist)
  in
  match pt with
  | PTVal _ -> (pt, declr)
  | PTPtr (aty, pa) ->
      if is_array declr then
        let tmp_declr = { declr with array_dims = [] } in
        let tmp_aty = Ptr aty in
        let tmp_cnt = get_count_attr declr.array_dims in
        let tmp_pa =
          { pa with pa_size = { empty_ptr_size with ps_count = Some tmp_cnt } }
        in
        (PTPtr (tmp_aty, tmp_pa), tmp_declr)
      else (pt, declr)

(** ----- End code borrowed and tweaked from {!CodeGen.ml} ----- *)

(* Helper to map and filter out None at the same time. *)
let filter_map f l = List.of_seq (Seq.filter_map f (List.to_seq l))

(* Helper to flatten and map at the same time. *)
let flatten_map f l = List.flatten (List.map f l)

let flatten_map2 f l m = List.flatten (List.map2 f l m)

let is_in_ptr = function
  | PTVal _ -> false
  | PTPtr (_, a) -> a.pa_chkptr && a.pa_direction = PtrIn

let is_out_ptr = function
  | PTVal _ -> false
  | PTPtr (_, a) -> a.pa_chkptr && a.pa_direction = PtrOut

let is_inout_ptr = function
  | PTVal _ -> false
  | PTPtr (_, a) -> a.pa_chkptr && a.pa_direction = PtrInOut

let is_in_or_inout_ptr (p, _) = is_in_ptr p || is_inout_ptr p

let is_out_or_inout_ptr (p, _) = is_out_ptr p || is_inout_ptr p

let is_str_ptr = function PTVal _ -> false | PTPtr (_, a) -> a.pa_isstr

let is_wstr_ptr = function PTVal _ -> false | PTPtr (_, a) -> a.pa_iswstr

let is_str_or_wstr_ptr (p, _) = is_str_ptr p || is_wstr_ptr p

(* This tests if the member has a non-empty size attribute,
   implying that it should be marshalled. *)
let is_marshalled_ptr = function
  | PTPtr (_, attr) -> attr.pa_size <> empty_ptr_size
  | PTVal _ -> false

let gen_c_for level count body =
  if count = "1" then body
  else
    let i = sprintf "_i_%i" level in
    [
      [ sprintf "for (size_t %s = 0; %s < %s; %s++)" i i count i ];
      [ "{" ];
      List.map (( ^ ) "    ") body;
      [ "}" ];
    ]
    |> List.flatten

let gen_c_deref level i = if i = "1" then "->" else sprintf "[_i_%i]." level

(** [write_file] opens [filename] in the directory [dir] and emits a
    comment noting the file is auto generated followed by the
    [content], it then closes the file. *)
let write_file (content : string list) (filename : string) (dir : string) =
  let os =
    if dir = "." then open_out filename
    else open_out (dir ^ Intel.Util.separator_str ^ filename)
  in
  fprintf os "%s"
    (String.concat "\n"
       ( [
           "/*";
           " *  This file is auto generated by oeedger8r. DO NOT EDIT.";
           " */";
         ]
       @ content ));
  close_out os

let get_type_expr ptype =
  (* Get the base type of the parameter. That is, yield its [atype],
     unless it is a pointer, in which case decompose and yield the
     [atype] the pointer points to. *)
  let param_atype =
    let a = get_param_atype ptype in
    match a with Ptr p -> p | _ -> a
  in
  let tystr = get_tystr param_atype in
  match ptype with
  | PTPtr (_, ptr_attr) when ptr_attr.pa_isptr -> sprintf "*(%s)0" tystr
  | _ -> tystr

(** For a list of args and current count, get the corresponding
   argstruct variable name. The prefix is usually, but not always,
   ["_args."].*)
let get_argstruct prefix args count =
  match args with
  | [] -> prefix
  | hd :: _ -> prefix ^ hd ^ gen_c_deref (List.length args) count

let attr_value_to_string argstruct = function
  | None -> None
  | Some (ANumber n) -> Some (string_of_int n)
  | Some (AString s) -> Some (argstruct ^ s)

(** For a parameter, get its size expression. *)
let _get_param_size (ptype, decl, argstruct) =
  let type_expr = get_type_expr ptype in
  let get_ptr_or_decl_size (p : ptr_size) =
    let size = attr_value_to_string argstruct p.ps_size
    and count = attr_value_to_string argstruct p.ps_count in
    match (size, count) with
    | Some s, None -> s
    | None, Some c -> sprintf "(%s * sizeof(%s))" c type_expr
    (* TODO: Check that this is an even multiple of the size of type. *)
    | Some s, Some c -> sprintf "(%s * %s)" s c
    | None, None ->
        sprintf "sizeof(%s%s)" type_expr (get_array_dims decl.array_dims)
  in
  match ptype with
  | PTPtr (_, ptr_attr) ->
      if ptr_attr.pa_isstr then
        Some (argstruct ^ decl.identifier ^ "_len * sizeof(char)")
      else if ptr_attr.pa_iswstr then
        Some (argstruct ^ decl.identifier ^ "_len * sizeof(wchar_t)")
      else if ptr_attr.pa_chkptr then
        Some (get_ptr_or_decl_size ptr_attr.pa_size)
      else None
  (* Values have no marshalling size. *)
  | _ -> None

let get_param_size (ptype, decl, argstruct) =
  match _get_param_size (ptype, decl, argstruct) with
  | Some size -> size
  | None -> Intel.Util.failwithf "Error: No size for " ^ decl.identifier

(** For a parameter, get its count expression. *)
let _get_param_count (ptype, decl, argstruct) =
  let type_expr = get_type_expr ptype in
  let get_ptr_or_decl_count (p : ptr_size) =
    let size = attr_value_to_string argstruct p.ps_size
    and count = attr_value_to_string argstruct p.ps_count in
    match (size, count) with
    (* TODO: Check that these are even multiples of the size of type. *)
    | Some s, None -> sprintf "(%s / sizeof(%s))" s type_expr
    | None, Some c -> c
    | Some s, Some c -> sprintf "((%s * %s) / sizeof(%s))" s c type_expr
    | None, None ->
        let dims = List.map string_of_int decl.array_dims in
        String.concat " * " dims
  in
  match ptype with
  | PTPtr (_, ptr_attr) ->
      (* The count of a string is its length. *)
      if ptr_attr.pa_isstr || ptr_attr.pa_iswstr then
        (* TODO: Double-check that this length includes the
           null-terminator. *)
        Some (argstruct ^ decl.identifier ^ "_len")
      else if ptr_attr.pa_chkptr then
        Some (get_ptr_or_decl_count ptr_attr.pa_size)
        (* TODO: Should be able to return [Some "1"] for plain
           pointers and values. *)
      else None
  | PTVal _ -> None

let get_param_count (ptype, decl, argstruct) =
  match _get_param_count (ptype, decl, argstruct) with
  | Some count -> count
  | None -> Intel.Util.failwithf "Error: No count for " ^ decl.identifier

(** Generate the wrapper prototype for a given function. Optionally
    add an [oe_enclave_t*] first parameter. *)
let get_wrapper_prototype (fd : func_decl) (is_ecall : bool) =
  let plist_str =
    let args =
      [
        (if is_ecall then [ "oe_enclave_t* enclave" ] else []);
        ( match fd.rtype with
        | Void -> []
        | _ -> [ get_tystr fd.rtype ^ "* _retval" ] );
        List.map get_parameter_str fd.plist;
      ]
      |> List.flatten
    in
    match args with
    | [ arg ] -> arg
    | _ -> "\n    " ^ String.concat ",\n    " args
  in
  sprintf "oe_result_t %s(%s)" fd.fname plist_str

let get_function_id (enclave_name : string) (f : func_decl) =
  enclave_name ^ "_fcn_id_" ^ f.fname
