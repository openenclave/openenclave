(* 
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the MIT License. 
*)

open Ast
open Plugin
open Printf
open Util  

(**************************** Begin Code borrowed and tweaked from CodeGen.ml *******************************************************)      
let is_foreign_array (pt: Ast.parameter_type) =
  match pt with
      Ast.PTVal _     -> false
    | Ast.PTPtr(t, a) ->
        match t with
            Ast.Foreign _ -> a.Ast.pa_isary
          | _             -> false
let get_array_dims (ns: int list) =
  (* Get the array declaration from a list of array dimensions.
   * Empty `ns' indicates the corresponding declarator is a simple identifier.
   * Element of value -1 means that user does not specify the dimension size.
   *)
  let get_dim n = if n = -1 then "[]" else sprintf "[%d]" n
  in
    if ns = [] then ""
    else List.fold_left (fun acc n -> acc ^ get_dim n) "" ns

let get_typed_declr_str (ty: Ast.atype) (declr: Ast.declarator) =
  let tystr = Ast.get_tystr  ty in
  let dmstr = get_array_dims declr.Ast.array_dims in
    sprintf "%s %s%s" tystr declr.Ast.identifier dmstr

(* Check whether given parameter is `const' specified. *)
let is_const_ptr (pt: Ast.parameter_type) =
  let aty = Ast.get_param_atype pt in
    match pt with
      Ast.PTVal _      -> false
    | Ast.PTPtr(_, pa) ->
      if not pa.Ast.pa_rdonly then false
      else
        match aty with
          Ast.Foreign _ -> false
        | _             -> true

(* Generate parameter representation. *)
let gen_parm_str (p: Ast.pdecl) =
  let (pt, (declr : Ast.declarator)) = p in
  let aty = Ast.get_param_atype pt in
  let str = get_typed_declr_str aty declr in
    if is_const_ptr pt then "const " ^ str else str

let retval_declr = { Ast.identifier = "_retval"; Ast.array_dims = []; }
let get_ret_tystr (fd: Ast.func_decl) = Ast.get_tystr fd.Ast.rtype
let get_plist_str (fd: Ast.func_decl) =
  if fd.Ast.plist = [] then ""
  else List.fold_left (fun acc pd -> acc ^ ",\n        " ^ gen_parm_str pd)
                      (gen_parm_str (List.hd fd.Ast.plist))
                      (List.tl fd.Ast.plist)


(* This function is used to convert Array form into Pointer form.
 * e.g.: int array[10][20]   =>  [count = 200] int* array
 *
 * This function is called when generating proxy/bridge code and
 * the marshaling structure.
 *)
let conv_array_to_ptr (pd: Ast.pdecl): Ast.pdecl =
  let (pt, declr) = pd in
  let get_count_attr ilist =
    (* XXX: assume the size of each dimension will be > 0. *)
    Ast.ANumber (List.fold_left (fun acc i -> acc*i) 1 ilist)
  in
    match pt with
      Ast.PTVal _        ->  (pt, declr)
    | Ast.PTPtr(aty, pa) ->
      if Ast.is_array declr then
        let tmp_declr = { declr with Ast.array_dims = [] } in
        let tmp_aty = Ast.Ptr aty in
        let tmp_cnt = get_count_attr declr.Ast.array_dims in
        let tmp_pa = { pa with Ast.pa_size = { Ast.empty_ptr_size with Ast.ps_count = Some tmp_cnt } }
        in (Ast.PTPtr(tmp_aty, tmp_pa), tmp_declr)
      else (pt, declr)

(* Note that, for a foreign array type `foo_array_t' we will generate
 *   foo_array_t* ms_field;
 * in the marshaling data structure to keep the pass-by-address scheme
 * as in the C programming language.
*)
let mk_ms_member_decl (pt: Ast.parameter_type) (declr: Ast.declarator) (isecall: bool) =
  let aty = Ast.get_param_atype pt in
  let tystr =  
    if is_foreign_array pt then 
      sprintf "/* foreign array of type %s */ void" (Ast.get_tystr aty)
    else Ast.get_tystr aty 
  in
  let ptr = if is_foreign_array pt then "* " else "" in
  let field = declr.Ast.identifier in
  (* String attribute is available for in/inout both ecall and ocall.
   * For ocall ,strlen is called in trusted proxy ocde, so no need to defense it.
   *)
  let need_str_len_var (pt: Ast.parameter_type) =
    match pt with
    Ast.PTVal _        -> false
    | Ast.PTPtr(_, pa) ->
    if pa.Ast.pa_isstr || pa.Ast.pa_iswstr then
        match pa.Ast.pa_direction with
        Ast.PtrInOut | Ast.PtrIn ->  if isecall then true else false
        | _ -> false
    else false
  in
  let str_len = if need_str_len_var pt then sprintf "\tsize_t %s_len;\n" field else ""
  in
  let dmstr = get_array_dims declr.Ast.array_dims in
    sprintf "\t%s%s %s%s;\n%s" tystr ptr field dmstr str_len

(**************************** END Code borrowed and tweaked from CodeGen.ml *******************************************************)      

(* Open a file for writing in the specified directory.
   Also emit auto-generated marker in file.
 *)
let open_file (filename:string) (dir:string) = 
    let os = if dir = "." then
              open_out filename
            else
              open_out (dir ^ separator_str ^ filename) in
    fprintf os "/*\n";
    fprintf os " *  This file is auto generated by oeedger8r. DO NOT EDIT.\n";    
    fprintf os " */\n";
    os


(* oe: util functions *)
let oe_mk_ms_struct_name (fname: string) = fname ^ "_args_t"

(* Construct the string of structure definition *)
let oe_mk_struct_decl (fs: string) (name: string) =
  sprintf "typedef struct _%s {\n%s    oe_result_t _result;\n } %s;\n" name fs name

(* oe: Generate marshaling structure definition *)
let oe_gen_marshal_struct_impl (fd: Ast.func_decl) (errno: string) (isecall: bool) =
  let member_list_str = errno ^
  let new_param_list = List.map conv_array_to_ptr fd.Ast.plist in
  List.fold_left (fun acc (pt, declr) ->
          acc ^ mk_ms_member_decl pt declr isecall) "" new_param_list in
let struct_name = oe_mk_ms_struct_name fd.Ast.fname in
  match fd.Ast.rtype with
      Ast.Void -> oe_mk_struct_decl member_list_str struct_name
    | _ -> let rv_str = mk_ms_member_decl (Ast.PTVal fd.Ast.rtype) retval_declr isecall
           in oe_mk_struct_decl (rv_str ^ member_list_str) struct_name

let oe_gen_ecall_marshal_struct (tf: Ast.trusted_func) =
    oe_gen_marshal_struct_impl tf.Ast.tf_fdecl "" true

let oe_gen_ocall_marshal_struct (uf: Ast.untrusted_func) =
    let errno_decl = if uf.Ast.uf_propagate_errno then "\tint _ocall_errno;\n" else "" in
    oe_gen_marshal_struct_impl uf.Ast.uf_fdecl errno_decl true

(* This is the most complex function. 
 * For a parameter, get its size expression.
*)
let oe_get_param_size (ptype, decl, argstruct) = 
  (* get the base type of the parameter *)
  let atype = 
    match Ast.get_param_atype ptype with
    | Ast.Ptr at -> at
    | _ -> Ast.get_param_atype ptype
  in 
  let base_t = Ast.get_tystr atype in

  let type_expr = 
    match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
        if ptr_attr.Ast.pa_isptr then
          sprintf "*(%s)0" base_t
        else base_t
      | _ -> base_t
  in

  (* convert an attribute to string *)
  let attr_value_to_string av = 
    match av with
    | None -> ""
    | Some (Ast.ANumber n) -> string_of_int n
    | Some (Ast.AString s) -> sprintf "%s%s" argstruct s  (* another parameter name *)
  in 
  let pa_size_to_string pa = 
    let c = attr_value_to_string pa.Ast.ps_count in
    if c <> "" then sprintf "(%s * sizeof(%s))" c type_expr
    else attr_value_to_string pa.Ast.ps_size
  in
  let decl_size_to_string (ptype:Ast.parameter_type) (d:Ast.declarator) =
    let dims = List.map  (fun i-> "[" ^ (string_of_int i) ^ "]") d.Ast.array_dims in
    let dims_expr = String.concat "" dims in
    sprintf "sizeof(%s%s)" type_expr dims_expr
  in
    match ptype with
        Ast.PTPtr (atype, ptr_attr) ->
          let pa_size = pa_size_to_string ptr_attr.Ast.pa_size in
          (* Compute declared size *)
          let decl_size = decl_size_to_string ptype decl in
          if ptr_attr.Ast.pa_isstr then
            argstruct ^ decl.Ast.identifier ^ "_len * sizeof(char)"
          else if ptr_attr.Ast.pa_iswstr then
            argstruct ^ decl.Ast.identifier ^ "_len * sizeof(wchar_t)" 
          else 
            (* Prefer size attribute over decl size *)
            if pa_size="" then decl_size else pa_size
        | _ -> ""


(* Generate the prototype for a given function.
 * Optionally add an oe_enclave_t* first parameter.
 *)
let oe_gen_prototype (fd: Ast.func_decl) =
  let params_str = 
      if List.length fd.Ast.plist = 0 then
        "void"
      else get_plist_str fd in
  sprintf "%s %s(%s)" (get_ret_tystr fd) fd.Ast.fname params_str

let oe_gen_wrapper_prototype (fd: Ast.func_decl) (is_ecall:bool) =
  let plist_str = get_plist_str fd in  
  let retval_str = 
    if fd.Ast.rtype = Ast.Void then ""
    else sprintf "%s* _retval" (get_ret_tystr fd) in  
  let args = 
    if is_ecall then
      ["oe_enclave_t* enclave"; retval_str; plist_str]
    else
      [retval_str; plist_str] in 
  let args = List.filter (fun s-> s <> "") args
  in 
    sprintf "oe_result_t %s(\n        %s)" fd.Ast.fname (String.concat ",\n        " args)

(*
  Emit struct or union
*)

let emit_struct_or_union  (os:out_channel) (s:Ast.struct_def) (union:bool) =
  fprintf os "typedef %s %s {\n" (if union then "union" else "struct") s.Ast.sname;
  List.iter (fun (atype, decl) -> 
    let dims = List.map (fun d-> sprintf "[%d]" d) decl.Ast.array_dims in
    let dims_str = String.concat "" dims in
    fprintf os "    %s %s%s;\n" (Ast.get_tystr atype) decl.Ast.identifier dims_str
  ) s.Ast.mlist;
  fprintf os "} %s;\n\n" s.Ast.sname

let emit_enum (os:out_channel) (e:Ast.enum_def) = 
  let n = List.length e.Ast.enbody in
  fprintf os "typedef enum %s {\n" e.Ast.enname;
  List.iteri (fun idx (name, value) ->
    fprintf os "    %s%s" name
    (match value with
      | Ast.EnumVal (Ast.AString s) -> " = " ^ s
      | Ast.EnumVal (Ast.ANumber n) -> " = " ^ (string_of_int n)
      | Ast.EnumValNone -> "");
    if idx != (n-1) then fprintf os ",\n"
  ) e.Ast.enbody;
  fprintf os "} %s;\n\n" e.Ast.enname

(*
* Emit composite types defined in edl.
*)  
let emit_composite_type (os:out_channel) = function
| Ast.StructDef s -> emit_struct_or_union os s false  
| Ast.UnionDef u -> emit_struct_or_union os u true
| Ast.EnumDef e -> emit_enum os e
  
(*
 * Get function id for a given function.
 *)
let get_function_id (f:Ast.func_decl) =
  sprintf "fcn_id_%s" f.fname

(*
 * Emit function ids.
 *)
let emit_function_ids (os:out_channel) (ec: enclave_content) = 
  fprintf os "\n/* trusted function ids */\n";
  fprintf os "enum {\n";
  List.iteri (fun idx f ->
    fprintf os "    %s = %d,\n" (get_function_id f.Ast.tf_fdecl) idx
  ) ec.tfunc_decls;
  fprintf os "    fcn_id_trusted_call_id_max = OE_ENUM_MAX\n";
  fprintf os "};\n\n";
  fprintf os "\n/* untrusted function ids */\n";
  fprintf os "enum {\n";
  List.iteri (fun idx f ->
    fprintf os "    %s = %d,\n" (get_function_id f.Ast.uf_fdecl) idx
  ) ec.ufunc_decls;
  fprintf os "    fcn_id_untrusted_call_max = OE_ENUM_MAX\n";
  fprintf os "};\n\n"

(* oe: Generate args.h which contains structs for ecalls and ocalls *)
let oe_gen_args_header (ec: enclave_content) (dir:string)=  
  let structs = List.append
    (* For each ecall, generate its marshalling struct *)
    (List.map oe_gen_ecall_marshal_struct ec.tfunc_decls)
    (* For each ocall, generate its marshalling struct *) 
    (List.map oe_gen_ocall_marshal_struct ec.ufunc_decls)
  in  
  let with_errno = List.exists (fun uf -> uf.Ast.uf_propagate_errno) ec.ufunc_decls in
  let header_fname = sprintf "%s_args.h" ec.file_shortnm in
  let guard_macro = sprintf "%s_ARGS_H" (String.uppercase ec.enclave_name) in
  let os = open_file header_fname dir in  
    fprintf os "#ifndef %s\n" guard_macro;
    fprintf os "#define %s\n\n" guard_macro;
    fprintf os "#include <stdint.h>\n";
    fprintf os "#include <stdlib.h> /* for wchar_t */ \n\n";
    if with_errno then fprintf os "#include <errno.h>\n";
    fprintf os "#include <openenclave/bits/result.h>\n\n";
    List.iter (fun inc -> fprintf os "#include \"%s\"\n" inc) ec.include_list;    
    if ec.include_list <> [] then fprintf os "\n";
    if ec.comp_defs <> [] then fprintf os "/* User types specified in edl */\n";
    List.iter (emit_composite_type os) ec.comp_defs;
    if ec.comp_defs <> [] then fprintf os "\n";
    fprintf os "%s" (String.concat "\n" structs);
    emit_function_ids os ec; 
    fprintf os "\n#endif // %s\n" guard_macro;
    close_out os
  
(* 
  Generate a cast expression for a pointer argument.
  Pointer arguments need to be cast to their root type, since the
  marshalling struct has the root pointer.
  For example, int a[10][20] needs to be cast to int *.
*)
let get_cast_to_mem_expr (ptype, decl)= 
  match ptype with
  | Ast.PTVal _ -> ""
  | Ast.PTPtr (t, _) ->
      if Ast.is_array decl then
        sprintf "(%s*) " (get_tystr t)
      else if is_foreign_array ptype then
        sprintf "/* foreign array of type %s */ " (get_tystr t)
      else 
        sprintf "(%s) " (get_tystr t)

(*
   Prepare input_buffer
*)
let oe_prepare_input_buffer (os:out_channel) (fd:Ast.func_decl) (alloc_func:string) =
  fprintf os "    /* Compute input buffer size. Include in and in-out parameters. */\n";
  fprintf os "    OE_ADD_SIZE(_input_buffer_size, sizeof(%s_args_t));\n" fd.Ast.fname;
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrIn | Ast.PtrInOut ->
          let size = oe_get_param_size (ptype, decl, "_args.") in
          fprintf os "    if (%s) OE_ADD_SIZE(_input_buffer_size, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n";
  fprintf os "    /* Compute output buffer size. Include out and in-out parameters. */\n";
  fprintf os "    OE_ADD_SIZE(_output_buffer_size, sizeof(%s_args_t));\n" fd.Ast.fname;
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrOut | Ast.PtrInOut ->
          let size = oe_get_param_size (ptype, decl, "_args.") in
          fprintf os "    if (%s) OE_ADD_SIZE(_output_buffer_size, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n";
  fprintf os "    /* Allocate marshaling buffer */\n";
  fprintf os "    _total_buffer_size = _input_buffer_size;\n";
  fprintf os "    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);\n\n";
  fprintf os "    _buffer = (uint8_t*) %s(_total_buffer_size);\n" alloc_func;
  fprintf os "    _input_buffer = _buffer;\n";
  fprintf os "    _output_buffer = _buffer + _input_buffer_size;\n";
  fprintf os "    if (_buffer == NULL) { \n";
  fprintf os "        _result = OE_OUT_OF_MEMORY;\n";
  fprintf os "        goto done;\n";
  fprintf os "    }\n\n";

  (* Serialize in and in-out parameters *)
  fprintf os "    /* Serialize buffer inputs (in and in-out parameters) */\n";
  fprintf os "    *(uint8_t**)&_pargs_in = _input_buffer; \n";
  fprintf os "    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));\n\n";
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "_args.") in
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrIn -> fprintf os "    OE_WRITE_IN_PARAM(%s, %s);\n" decl.Ast.identifier size
        | Ast.PtrInOut -> fprintf os "    OE_WRITE_IN_OUT_PARAM(%s, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n    /* Copy args structure (now filled) to input buffer */\n";
  fprintf os "    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));\n\n"

let oe_process_output_buffer (os:out_channel) (fd:Ast.func_decl) =
  (* Verify that the ecall succeeded *)
  fprintf os "    /* Set up output arg struct pointer*/\n";
  fprintf os "    *(uint8_t**)&_pargs_out = _output_buffer; \n";
  fprintf os "    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));\n\n";
  fprintf os "    /* Check if the call succeeded */\n";
  fprintf os "    if ((_result=_pargs_out->_result) != OE_OK)\n";
  fprintf os "        goto done;\n\n";
  fprintf os "    /* Currently exactly _output_buffer_size bytes must be written */\n";
  fprintf os "    if (_output_bytes_written != _output_buffer_size) {\n";
  fprintf os "        _result = OE_FAILURE;\n";
  fprintf os "        goto done;\n";
  fprintf os "    }\n\n";


  (* Unmarshal return value and ouput buffers *)
  fprintf os "    /* Unmarshal return value and out, in-out parameters */\n";
  (if fd.Ast.rtype <> Ast.Void then
    fprintf os "    *_retval = _pargs_out->_retval;\n");
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "_args.") in
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrOut -> fprintf os "    OE_READ_OUT_PARAM(%s, (size_t)(%s));\n" decl.Ast.identifier size
        | Ast.PtrInOut -> fprintf os "    OE_READ_IN_OUT_PARAM(%s, (size_t)(%s));\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n"


(* 
  Generate a cast expression to a specific pointer type.  
  For example, int* needs to be cast to  * (int ( *  )[5][6]).
*)
let get_cast_from_mem_expr (ptype, decl)= 
  match ptype with
  | Ast.PTVal _ -> ""
  | Ast.PTPtr (t, attr) ->
      if Ast.is_array decl then
        sprintf "*(%s (*)%s) " (get_tystr t) (get_array_dims decl.Ast.array_dims)
      else if is_foreign_array ptype then
        sprintf "/*foreign array*/ *(%s *) " (get_tystr t)
      else
        if attr.Ast.pa_rdonly then
           (* for ptrs, only constness is removed; add it back *)
           sprintf "(const %s) " (get_tystr t)
        else ""
  
let oe_copy_members_to_enclave (os:out_channel) (fd: Ast.func_decl) =  
  let is_primitive ptype =
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) -> not ptr_attr.Ast.pa_chkptr
    | _ -> true     
  in
  let gen_copy_member (ptype, decl) =
    if is_primitive ptype then
      fprintf os "    enc_args.%s = args.%s;\n"      
        decl.Ast.identifier
        decl.Ast.identifier
  in 
  fprintf os "    /* Copy primitive properties to enc_args */\n";
  List.iter gen_copy_member fd.Ast.plist;
  fprintf os "\n"

let oe_gen_allocate_buffers (os:out_channel) (fd: Ast.func_decl) =    
  let gen_allocate_buffer (ptype, decl) =
    match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
          if ptr_attr.Ast.pa_chkptr then
            let size = oe_get_param_size (ptype, decl, "args.") in
            let macro = 
              match ptr_attr.Ast.pa_direction with
                | Ast.PtrOut -> "OE_CHECKED_ALLOCATE_OUTPUT"                
                | _ -> "OE_CHECKED_COPY_INPUT"
            in 
            fprintf os "    %s(enc_args.%s, args.%s, %s); \n" 
                macro decl.Ast.identifier 
                decl.Ast.identifier
                size            
          else ()
      | _ -> () (* Non pointer arguments *)    
  in 
  fprintf os "    /* Copy checked buffers properties to enclave memory */\n";
  List.iter gen_allocate_buffer fd.Ast.plist;
  fprintf os "\n"
  
let oe_gen_free_buffers (os:out_channel) (fd: Ast.func_decl) =  
  let gen_free_buffer (ptype, decl) =
    match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
          if ptr_attr.Ast.pa_chkptr then
            (fprintf os "    if (enc_args.%s)\n" decl.Ast.identifier;
             fprintf os "        free (enc_args.%s); \n" decl.Ast.identifier)            
          else ()
      | _ -> () (* Non pointer arguments *)    
  in 
  fprintf os "    /* Free enclave buffers */\n";
  List.iter gen_free_buffer fd.Ast.plist;
  fprintf os "\n"

let oe_gen_copy_outputs (os:out_channel) (fd: Ast.func_decl) =  
  let gen_free_buffer (ptype, decl) =
    match ptype with
      | Ast.PTPtr (atype, ptr_attr) ->
          if ptr_attr.Ast.pa_chkptr then
            match ptr_attr.Ast.pa_direction with
            Ast.PtrOut | Ast.PtrInOut -> 
              fprintf os "    if (args.%s)\n" decl.Ast.identifier;
              fprintf os "        memcpy(args.%s, enc_args.%s, %s);\n"
                decl.Ast.identifier
                decl.Ast.identifier
                (oe_get_param_size (ptype, decl, "args."))              
            | _ -> ()               
          else ()
      | _ -> () (* Non pointer arguments *)    
  in 
  fprintf os "\n    /* Copy output buffers */\n";
  List.iter gen_free_buffer fd.Ast.plist;
  fprintf os "\n"  
  
let oe_gen_call_function (os:out_channel) (fd: Ast.func_decl) =
  let params = List.map (fun (pt, decl) -> 
    sprintf "%spargs_in->%s" (get_cast_from_mem_expr (pt, decl))decl.Ast.identifier) fd.Ast.plist
  in
  let params_str = "(\n        " ^ (String.concat ",\n        " params ) ^ ")" in
  let ret_str = match fd.Ast.rtype with
    | Ast.Void -> ""
    | _ -> "pargs_out->_retval = " in
  let call_str = ret_str ^ fd.Ast.fname ^ params_str in
  fprintf os "    /* Call user function */\n";
  fprintf os "    %s;\n" call_str  

(* oe: Generate ecall function . *)
let oe_gen_ecall_function (os:out_channel) (fd: Ast.func_decl) =  
  fprintf os "void ecall_%s(\n" fd.Ast.fname;
  fprintf os "        uint8_t* input_buffer, size_t input_buffer_size,\n";
  fprintf os "        uint8_t* output_buffer, size_t output_buffer_size,\n";
  fprintf os "        size_t* output_bytes_written)\n";
  fprintf os "{\n";

  (* Variable declarations *)
  fprintf os "    oe_result_t _result = OE_FAILURE;\n\n";
  fprintf os "    /* Prepare parameters */\n";
  fprintf os "    %s_args_t* pargs_in = (%s_args_t*) input_buffer;\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    %s_args_t* pargs_out = (%s_args_t*) output_buffer;\n\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    size_t input_buffer_offset = 0;\n";
  fprintf os "    size_t output_buffer_offset = 0;\n";
  fprintf os "    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));\n";
  fprintf os "    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));\n\n";

  (* Buffer validation *)
  fprintf os "    /* Make sure input and output buffers lie within the enclave */\n";
  fprintf os "    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))\n";
  fprintf os "        goto done;\n\n";
  fprintf os "    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))\n";
  fprintf os "        goto done;\n\n";

  (* Prepare in and in-out parameters *)
  fprintf os "    /* Set in and in-out pointers */\n";
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "pargs_in->") in
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrIn -> fprintf os "    OE_SET_IN_POINTER(%s, %s);\n" decl.Ast.identifier size
        | Ast.PtrInOut -> fprintf os "    OE_SET_IN_OUT_POINTER(%s, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n";

  (* Prepare out and in-out parameters. The in-out parameter is copied to output buffer. *)
  fprintf os "    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */\n";
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "pargs_in->") in
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrOut -> fprintf os "    OE_SET_OUT_POINTER(%s, %s);\n" decl.Ast.identifier size
        | Ast.PtrInOut -> fprintf os "    OE_COPY_AND_SET_IN_OUT_POINTER(%s, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n";

  (* Call the enclave function *)
  fprintf os "    /* lfence after checks */\n";
  fprintf os "    oe_lfence();\n\n";
  oe_gen_call_function os fd;

  (* Mark call as success *)
  fprintf os "\n    /* Success. */\n";
  fprintf os "    _result = OE_OK; \n";
  fprintf os "    *output_bytes_written = output_buffer_offset;\n\n";
  fprintf os "done:\n";

  (* oe_gen_free_buffers os fd; *)
  fprintf os "    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) \n";
  fprintf os "        pargs_out->_result = _result;\n";
  fprintf os "}\n\n"
  

let oe_gen_ecall_functions (os:out_channel) (ec: enclave_content)  =
  fprintf os "\n\n/****** ECALL function wrappers  *************/\n";
  List.iter 
    (fun f -> oe_gen_ecall_function os f.Ast.tf_fdecl)
    ec.tfunc_decls

let oe_gen_ecall_table (os:out_channel) (ec: enclave_content)  =
  fprintf os "\n\n/****** ECALL function table  *************/\n";
  fprintf os "oe_ecall_func_t __oe_ecalls_table[] = {\n";
  List.iter 
    (fun f -> fprintf os "    (oe_ecall_func_t) ecall_%s,\n" f.Ast.tf_fdecl.fname)
    ec.tfunc_decls;
  fprintf os "};\n\n";
  fprintf os "size_t __oe_ecalls_table_size = OE_COUNTOF(__oe_ecalls_table);\n\n"
  
let gen_fill_marshal_struct (os:out_channel) (fd:Ast.func_decl)  (args:string) =
  (* Generate assignment argument to corresponding field in args *)
  List.iter (fun (ptype, decl)->
    let varname = decl.Ast.identifier in 
    fprintf os "    %s.%s = %s%s;\n" args varname (get_cast_to_mem_expr (ptype, decl)) varname; 
    (* for string parameter fill the len field *)
    match ptype with
        | Ast.PTPtr(_, attr) -> 
            if attr.Ast.pa_isstr then 
                fprintf os "    %s.%s_len = (%s) ? (strlen(%s) + 1) : 0;\n" args varname varname varname 
            else if attr.Ast.pa_iswstr then
                fprintf os "    %s.%s_len = (%s) ? (wcslen(%s) + 1) : 0;\n" args varname varname varname
        | _ ->()
  ) fd.Ast.plist;
  fprintf os "\n"

let oe_get_host_ecall_function (os:out_channel) (fd:Ast.func_decl) =
  fprintf os "%s" (oe_gen_wrapper_prototype fd true);
  fprintf os "\n";
  fprintf os "{\n";
  fprintf os "    oe_result_t _result = OE_FAILURE;\n\n";
  fprintf os "    /* Marshaling struct */ \n";
  fprintf os "    %s_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;\n\n" fd.Ast.fname;
  fprintf os "    /* Marshaling buffer and sizes */ \n";
  fprintf os "    size_t _input_buffer_size = 0;\n";
  fprintf os "    size_t _output_buffer_size = 0;\n";
  fprintf os "    size_t _total_buffer_size = 0;\n";
  fprintf os "    uint8_t* _buffer = NULL;\n";
  fprintf os "    uint8_t* _input_buffer = NULL;\n";
  fprintf os "    uint8_t* _output_buffer = NULL;\n";
  fprintf os "    size_t _input_buffer_offset = 0;\n";
  fprintf os "    size_t _output_buffer_offset = 0;\n";
  fprintf os "    size_t _output_bytes_written = 0;\n\n";
  fprintf os "    /* Fill marshaling struct */\n";
  fprintf os "    memset(&_args, 0, sizeof(_args));\n";
  gen_fill_marshal_struct os fd "_args";
  oe_prepare_input_buffer os fd "malloc";
  fprintf os "    /* Call enclave function */\n";
  fprintf os "    if((_result = oe_call_enclave_function(\n";
  fprintf os "                        enclave,\n";
  fprintf os "                        %s,\n" (get_function_id fd);
  fprintf os "                        _input_buffer, _input_buffer_size,\n";
  fprintf os "                        _output_buffer, _output_buffer_size,\n";
  fprintf os "                         &_output_bytes_written)) != OE_OK)\n";
  fprintf os "        goto done;\n\n";
  oe_process_output_buffer os fd;
  fprintf os "    _result = OE_OK;\n";
  fprintf os "done:    \n";  
  fprintf os "    if (_buffer)\n";
  fprintf os "        free(_buffer);\n";
  fprintf os "    return _result;\n";
  fprintf os "}\n\n"

let iter_ptr_params f params = 
  List.iter (fun (ptype, decl)->
    match ptype with
        | Ast.PTPtr(_, attr) ->  f (ptype, decl, attr)
        | _ ->()
  ) params

(* Generate ocalls wrapper function *)
let oe_gen_ocall_enclave_wrapper (os:out_channel) (uf:Ast.untrusted_func) =
  let propagate_errno = uf.Ast.uf_propagate_errno in
  let fd = uf.Ast.uf_fdecl in
  fprintf os "%s" (oe_gen_wrapper_prototype fd false);
  fprintf os "\n";
  fprintf os "{\n";
  fprintf os "    oe_result_t _result = OE_FAILURE;\n\n";
  fprintf os "    /* Marshaling struct */ \n";
  fprintf os "    %s_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;\n\n" fd.Ast.fname;
  fprintf os "    /* Marshaling buffer and sizes */ \n";
  fprintf os "    size_t _input_buffer_size = 0;\n";
  fprintf os "    size_t _output_buffer_size = 0;\n";
  fprintf os "    size_t _total_buffer_size = 0;\n";
  fprintf os "    uint8_t* _buffer = NULL;\n";
  fprintf os "    uint8_t* _input_buffer = NULL;\n";
  fprintf os "    uint8_t* _output_buffer = NULL;\n";
  fprintf os "    size_t _input_buffer_offset = 0;\n";
  fprintf os "    size_t _output_buffer_offset = 0;\n";
  fprintf os "    size_t _output_bytes_written = 0;\n\n";
  fprintf os "    /* Fill marshaling struct */\n";
  fprintf os "    memset(&_args, 0, sizeof(_args));\n";
  gen_fill_marshal_struct os fd "_args";
  oe_prepare_input_buffer os fd "oe_allocate_ocall_buffer";
  fprintf os "    /* Call host function */\n";
  fprintf os "    if((_result = oe_call_host_function(\n";
  fprintf os "                        %s,\n" (get_function_id fd);
  fprintf os "                        _input_buffer, _input_buffer_size,\n";
  fprintf os "                        _output_buffer, _output_buffer_size,\n";
  fprintf os "                         &_output_bytes_written)) != OE_OK)\n";
  fprintf os "        goto done;\n\n";
  oe_process_output_buffer os fd;

  (* Propagate errno *)
  (if propagate_errno then
    begin
    fprintf os "    /* Propagate errno */\n";
    fprintf os "    errno = _pargs_out->_ocall_errno;\n\n";
    end);

  fprintf os "    _result = OE_OK;\n";
  fprintf os "done:    \n";
  fprintf os "    if (_buffer)\n";
  fprintf os "        oe_free_ocall_buffer(_buffer);\n";
  fprintf os "    return _result;\n";
  fprintf os "}\n\n"

(*
 * Generate ocall function table and registration
 *)  
let oe_gen_ocall_table (os:out_channel) (ec:enclave_content) =
  fprintf os "\n/*ocall function table*/\n";
  fprintf os "static oe_ocall_func_t __%s_ocall_function_table[]= {\n" ec.enclave_name;
  List.iter (fun fd ->
    fprintf os "    (oe_ocall_func_t) ocall_%s,\n" fd.Ast.uf_fdecl.fname
  )  ec.ufunc_decls;
  fprintf os "    NULL\n";
  fprintf os "};\n\n"

(* Generate ocalls wrapper function *)
let oe_gen_ocall_host_wrapper (os:out_channel) (uf:Ast.untrusted_func) =
  let propagate_errno = uf.Ast.uf_propagate_errno in
  let fd = uf.Ast.uf_fdecl in
  fprintf os "void ocall_%s(\n" fd.Ast.fname;
  fprintf os "        uint8_t* input_buffer, size_t input_buffer_size,\n";
  fprintf os "        uint8_t* output_buffer, size_t output_buffer_size,\n";
  fprintf os "        size_t* output_bytes_written)\n";
  (* Variable declarations *)
  fprintf os "{\n";
  fprintf os "    oe_result_t _result = OE_FAILURE;\n";
  fprintf os "    OE_UNUSED(input_buffer_size);\n\n";
  fprintf os "    /* Prepare parameters */\n";
  fprintf os "    %s_args_t* pargs_in = (%s_args_t*) input_buffer;\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    %s_args_t* pargs_out = (%s_args_t*) output_buffer;\n\n" fd.Ast.fname fd.Ast.fname;
  fprintf os "    size_t input_buffer_offset = 0;\n";
  fprintf os "    size_t output_buffer_offset = 0;\n";
  fprintf os "    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));\n";
  fprintf os "    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));\n\n";

  (* Buffer validation *)
  fprintf os "    /* Make sure input and output buffers are valid */\n";
  fprintf os "    if (!input_buffer || !output_buffer) {\n";
  fprintf os "        _result = OE_INVALID_PARAMETER;\n";
  fprintf os "        goto done;\n\n";
  fprintf os "    }\n";

  (* Prepare in and in-out parameters *)
  fprintf os "    /* Set in and in-out pointers */\n";
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "pargs_in->") in
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrIn -> fprintf os "    OE_SET_IN_POINTER(%s, %s);\n" decl.Ast.identifier size
        | Ast.PtrInOut -> fprintf os "    OE_SET_IN_OUT_POINTER(%s, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n";

  (* Prepare out and in-out parameters. The in-out parameter is copied to output buffer. *)
  fprintf os "    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */\n";
  List.iter (fun (ptype, decl) ->
    match ptype with
    | Ast.PTPtr (atype, ptr_attr) ->
      if ptr_attr.Ast.pa_chkptr then
        let size = oe_get_param_size (ptype, decl, "pargs_in->") in
        match ptr_attr.Ast.pa_direction with
        | Ast.PtrOut -> fprintf os "    OE_SET_OUT_POINTER(%s, %s);\n" decl.Ast.identifier size
        | Ast.PtrInOut -> fprintf os "    OE_COPY_AND_SET_IN_OUT_POINTER(%s, %s);\n" decl.Ast.identifier size
        | _ -> ()
      else ()
    | _ -> ()
  ) fd.Ast.plist;
  fprintf os "\n";

  (* Call the host function *)
  oe_gen_call_function os fd;

  (* Propagate errno *)
  (if propagate_errno then
    begin
    fprintf os "\n    /* Propagate errno */\n";
    fprintf os "    pargs_out->_ocall_errno = errno;\n";
    end);

  (* Mark call as success *)
  fprintf os "\n    /* Success. */\n";
  fprintf os "    _result = OE_OK; \n";
  fprintf os "    *output_bytes_written = output_buffer_offset;\n\n";
  fprintf os "done:\n";

  (* oe_gen_free_buffers os fd; *)
  fprintf os "    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) \n";
  fprintf os "        pargs_out->_result = _result;\n";
  fprintf os "}\n\n"

(* 
  Check if any of the parameters or the return type
  has the given root type.
*)  
let uses_type (root_type:Ast.atype) (fd:Ast.func_decl) =
  let param_match = 
    List.exists (fun (pt, decl) -> 
      root_type =  (Ast.get_param_atype pt)
    ) fd.Ast.plist in
  if param_match then
    param_match 
  else
    root_type = fd.Ast.rtype

let warn_non_portable_types (fd:Ast.func_decl) =
    let print_portability_warning ty =
        printf "Warning: Function '%s': %s has different sizes on Windows and Linux. \
                This enclave cannot be built in Linux and then safely loaded in Windows.\n"
                fd.fname ty
    in
    let print_portability_warning_with_recommendation ty recommendation =
        printf "Warning: Function '%s': %s has different sizes on Windows and Linux. \
        This enclave cannot be built in Linux and then safely loaded in Windows. \
        Consider using %s instead.\n"        
        fd.fname ty recommendation                     
    in
    (* longs are represented as an Ast.Int type *)
    let long_t = Ast.Int { Ast.ia_signedness = Ast.Signed; Ast.ia_shortness = Ast.ILong} in
    let ulong_t = Ast.Int { Ast.ia_signedness = Ast.Unsigned; Ast.ia_shortness = Ast.ILong} in
    
    (if uses_type Ast.WChar fd then
      print_portability_warning "wchar_t");
    (if uses_type Ast.LDouble fd then
      print_portability_warning "long double");

    (* Handle long type *)
    (if uses_type (Ast.Long Ast.Signed) fd || uses_type long_t fd then
      print_portability_warning_with_recommendation "long" "int64_t or int32_t");
    
    (* Handle unsigned long type *)
    (if uses_type (Ast.Long Ast.Unsigned) fd || uses_type ulong_t fd then
      print_portability_warning_with_recommendation "unsigned long" "uint64_t or uint32_t")

(* Valid oe support *)
let validate_oe_support (ec: enclave_content) (ep: edger8r_params) =
  (* check supported options *)
  if ep.use_prefix then failwithf "--use_prefix option is not supported by oeedger8r.";
  List.iter (fun f -> 
    (if f.Ast.tf_is_priv then 
        failwithf "Function '%s': 'private' specifier is not supported by oeedger8r" f.Ast.tf_fdecl.fname);
    (if f.Ast.tf_is_switchless then
        failwithf "Function '%s': switchless ecalls and ocalls are not yet supported by Open Enclave SDK." f.Ast.tf_fdecl.fname);  
    warn_non_portable_types f.Ast.tf_fdecl;   
  ) ec.tfunc_decls;
  List.iter (fun f -> 
    (if f.Ast.uf_fattr.fa_convention <> Ast.CC_NONE then
        let cconv_str = Ast.get_call_conv_str f.Ast.uf_fattr.Ast.fa_convention in
        printf "Warning: Function '%s': Calling convention '%s' for ocalls is not supported by oeedger8r.\n" f.Ast.uf_fdecl.fname cconv_str);
    (if f.Ast.uf_fattr.fa_dllimport then
        failwithf "Function '%s': dllimport is not supported by oeedger8r." f.Ast.uf_fdecl.fname);
    (if f.Ast.uf_allow_list != [] then
        printf "Warning: Function '%s': Reentrant ocalls are not supported by Open Enclave. Allow list ignored.\n" f.Ast.uf_fdecl.fname);
    (if f.Ast.uf_is_switchless then
        failwithf "Function '%s': switchless ecalls and ocalls are not yet supported by Open Enclave SDK." f.Ast.uf_fdecl.fname);
    warn_non_portable_types f.Ast.uf_fdecl;          
  ) ec.ufunc_decls

  (*
    Includes are emitted in args.h.
    Imported functions have already been brought into function lists.
  *)  

let gen_t_h (ec: enclave_content) (ep: edger8r_params) =
  let fname = ec.file_shortnm ^ "_t.h" in
  let guard = sprintf "EDGER8R_%s_T_H" (String.uppercase ec.file_shortnm) in
  let os = open_file fname ep.trusted_dir in  
  fprintf os "#ifndef %s\n" guard;
  fprintf os "#define %s\n\n" guard;
  fprintf os "#include <openenclave/enclave.h>\n";  
  fprintf os "#include \"%s_args.h\"\n\n" ec.file_shortnm;  
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  if ec.tfunc_decls <> [] then (
    fprintf os "/* List of ecalls */\n\n";
    List.iter (fun f -> fprintf os "%s;\n" (oe_gen_prototype f.Ast.tf_fdecl)) ec.tfunc_decls;
    fprintf os "\n");
  if ec.ufunc_decls <> [] then (
    fprintf os "/* List of ocalls */\n\n";
    List.iter (fun d -> fprintf os"%s;\n" (oe_gen_wrapper_prototype d.Ast.uf_fdecl false))  ec.ufunc_decls;
    fprintf os "\n");
  fprintf os "OE_EXTERNC_END\n\n";
  fprintf os "#endif // %s\n" guard;
  close_out os  

let gen_t_c (ec: enclave_content) (ep: edger8r_params) =
  let ecalls_fname = ec.file_shortnm ^ "_t.c" in
  let os = open_file ecalls_fname ep.trusted_dir in
  fprintf os "#include \"%s_t.h\"\n" ec.file_shortnm;  
  fprintf os "#include <openenclave/edger8r/enclave.h>\n";  
  fprintf os "#include <stdlib.h>\n";
  fprintf os "#include <string.h>\n";
  fprintf os "#include <wchar.h>\n";  
  fprintf os "\n";
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  if ec.tfunc_decls <> [] then (
    oe_gen_ecall_functions os ec;
    oe_gen_ecall_table os ec);
  if ec.ufunc_decls <> [] then (
    fprintf os "\n/* ocall wrappers */\n\n";
    List.iter (fun d -> oe_gen_ocall_enclave_wrapper os d)  ec.ufunc_decls);
  fprintf os "\nOE_ECALL void _dummy_old_style_ecall_to_keep_loader_happy(void* arg)\n";
  fprintf os "{\n";
  fprintf os "    OE_UNUSED(arg);\n";
  fprintf os "}\n\n";
  fprintf os "OE_EXTERNC_END\n";
  close_out os 

let oe_emit_create_enclave_decl (os:out_channel)  (ec:enclave_content) =
  fprintf os "oe_result_t oe_create_%s_enclave(const char* path,\n" ec.enclave_name;
  fprintf os "                                 oe_enclave_type_t type,\n";
  fprintf os "                                 uint32_t flags,\n";
  fprintf os "                                 const void* config,\n";
  fprintf os "                                 uint32_t config_size,\n";
  fprintf os "                                 oe_enclave_t** enclave);\n\n"

let oe_emit_create_enclave_defn (os:out_channel)  (ec:enclave_content) =
  fprintf os "oe_result_t oe_create_%s_enclave(const char* path,\n" ec.enclave_name;
  fprintf os "                                 oe_enclave_type_t type,\n";
  fprintf os "                                 uint32_t flags,\n";
  fprintf os "                                 const void* config,\n";
  fprintf os "                                 uint32_t config_size,\n";
  fprintf os "                                 oe_enclave_t** enclave)\n";
  fprintf os "{\n";
  fprintf os "    return oe_create_enclave(path,\n";
  fprintf os "               type,\n";
  fprintf os "               flags,\n";
  fprintf os "               config,\n";
  fprintf os "               config_size,\n";
  fprintf os "               __%s_ocall_function_table,\n" ec.enclave_name;
  fprintf os "               %d,\n" (List.length ec.ufunc_decls);
  fprintf os "               enclave);\n";
  fprintf os "}\n\n"


let gen_u_h (ec: enclave_content) (ep: edger8r_params) =
  let fname = ec.file_shortnm ^ "_u.h" in
  let guard = sprintf "EDGER8R_%s_U_H" (String.uppercase ec.file_shortnm) in
  let os = open_file fname ep.untrusted_dir in  
  fprintf os "#ifndef %s\n" guard;
  fprintf os "#define %s\n\n" guard;
  fprintf os "#include <openenclave/host.h>\n";  
  fprintf os "#include \"%s_args.h\"\n\n" ec.file_shortnm;  
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  oe_emit_create_enclave_decl os ec;
  if ec.tfunc_decls <> [] then (
    fprintf os "/* List of ecalls */\n\n";
    List.iter (fun f -> fprintf os "%s;\n" (oe_gen_wrapper_prototype f.Ast.tf_fdecl true)) ec.tfunc_decls;
    fprintf os "\n");
  if ec.ufunc_decls <> [] then (
    fprintf os "/* List of ocalls */\n\n";
    List.iter (fun d -> fprintf os"%s;\n" (oe_gen_prototype d.Ast.uf_fdecl))  ec.ufunc_decls;
    fprintf os "\n");
  fprintf os "OE_EXTERNC_END\n\n";
  fprintf os "#endif // %s\n" guard;
  close_out os  


let gen_u_c (ec: enclave_content) (ep: edger8r_params) =
  let ecalls_fname = ec.file_shortnm ^ "_u.c" in
  let os = open_file ecalls_fname ep.untrusted_dir in
  fprintf os "#include \"%s_u.h\"\n" ec.file_shortnm;  
  fprintf os "#include <openenclave/edger8r/host.h>\n";  
  fprintf os "#include <stdlib.h>\n";
  fprintf os "#include <string.h>\n";
  fprintf os "#include <wchar.h>\n";  
  fprintf os "\n";
  fprintf os "OE_EXTERNC_BEGIN\n\n";
  if ec.tfunc_decls <> [] then (
    fprintf os "/* Wrappers for ecalls */\n\n";
    List.iter (fun d -> oe_get_host_ecall_function os d.Ast.tf_fdecl; fprintf os "\n\n")  ec.tfunc_decls);
  if ec.ufunc_decls <> [] then (
    fprintf os "\n/* ocall functions */\n\n";
    List.iter (fun d -> oe_gen_ocall_host_wrapper os d) ec.ufunc_decls);
  oe_gen_ocall_table os ec;
  oe_emit_create_enclave_defn os ec;
  fprintf os "OE_EXTERNC_END\n";
  close_out os   

(* Generate the Enclave code. *)
let gen_enclave_code (ec: enclave_content) (ep: edger8r_params) =
  validate_oe_support ec ep;
  
  if ep.gen_trusted then(
    oe_gen_args_header ec ep.trusted_dir;
    gen_t_h ec ep;
    if not ep.header_only then
      gen_t_c ec ep;
  );
  if ep.gen_untrusted then (
    oe_gen_args_header ec ep.untrusted_dir;
    gen_u_h ec ep;
    if not ep.header_only then
      gen_u_c ec ep;
  );
  printf "Success.\n"


(* Install the plugin *)
let _ = 
  Printf.printf "Generating edge routines for the Open Enclave SDK.\n";
  Plugin.instance.available <- true;
  Plugin.instance.gen_edge_routines <- gen_enclave_code;

